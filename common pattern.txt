    def removeElement(self, nums: List[int], val: int):
        j = 0
        
        for i in range(len(nums)):
            if nums[i] != val:
                nums[j] = nums[i]
                j += 1

        return j


this inner code is a pattern. when you are starting from begining.
you have to delete one value assign something from next.
here you will use some condition to check for deletion. if true then pop.
this make further elements to shift left.

now problem comes if same condition appears consectively twice + times.
next element is already shifted to left and you have already checked current index.
This is where answers starts getting wrong.

To avoid this above pattern make sure with opposite logic.
two pointers are made. will keep moving one by one like scanning array.
another one will only move if opposite condition is met.
if condition is not met then do swapping with element.

This above part is very important.

Now if actual condition is met then no swappnig happens and also another pointer stays there.

This method saves memory by not creating any extra variable.
But it makes unnecessary swaps as well.


-------------------------------------------------------------------------------------------

        x, y = 0, 0

        for m in moves:
            match m:
                case "U":
                    y += 1
                case "D":
                    y -= 1
                case "L":
                    x -= 1
                case "R":
                    x += 1

        return x == 0 and y == 0

if you ever have to use if statements for many times, then use match and case statement like above.
it shall be used only when either of case is definitely going to occure.


----------------------------------------------------------------------------------

in python coding we can use "\" this character if we want continue same line of coding onto next line,
but want to see it in the same screen insread of using left to right scrolling.

---------------------------------------------------------------------------------

ord(char) → character to ASCII number
chr(num) → ASCII number to character
XOR operator symbol: ^
XOR rules: 0^0=0, 1^1=0, 0^1=1, 1^0=1
XOR works bit by bit, not on whole numbers, Even if number is given it converts into bits and then perform
operation.
Same numbers XORed cancel out → x ^ x = 0 and XOR with 0 keeps value → x ^ 0 = x

example, If we given s and t as input of string list, we have to check what extra character t has.
we combined s & t , s = "abcd"
t = "abcde"

s+t = "abcdabcde"

All paired characters cancel out after XOR operation.
✔ Only ASCII of 'e' remains:

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        result = 0
        for c in s + t:
            result ^= ord(c)
        return chr(result)

---------------------------------------------------------------------------------
How to know it's a Binary Search ??

1) tell the maximum of minimums, tell the minimum of maximums (90%)
2) if the array is sorted in arsc/desc
3) If there are certain possible answers, and you need to 
find the best ans among all the pool of answers, (75%) 

In binary search we have remember few things.
1.  while left <= right:
2. if found at middle then return the index or true
3. second if condition has to greater than given target or rightmost number.

binary search pattern code:

        while left <= right:
            mid = (left + right) // 2
            if mid * mid == num:
                return True
            if (mid * mid) > num:
                right = mid - 1
            else:
                left = mid + 1

------------------------------------------------------------------------
Remember there is an unique case of bs.
We have to check first occurence and may be others also in sorted array.
here two important things happens.
while left < right
and right do not decrease. it stays with mid.
And the moment we found our first occurece with left, We keep our left
there only.
In the end we return left. check the code:

while left < right:
                mid = (left + right) // 2

                if nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid

            return left


------------------------------------------------------------------------

Just a note:
Unicode defines characters and assigns code points. UTF-8 is an encoding that converts
 those code points into bytes for storage and transmission.
 UTF-8 is variable-length, efficient, and backward compatible with ASCII,
 which is why it is the dominant encoding today.

------------------------------------------------------------------------------------------

Sliding Window Template:

initialize window
for each step:
    add new element
    remove old element
    update result

example: Find the maximum sum of any subarray of size k.

Example
nums = [2, 1, 5, 1, 3, 2]
k = 3


Subarrays of size 3:

[2,1,5] → sum = 8

[1,5,1] → sum = 7

[5,1,3] → sum = 9 ✅

[1,3,2] → sum = 6

Answer = 9

Sliding Window Approach (BEST)
 Code (memorize this pattern):

class Solution:
    def maxSubArraySum(self, nums, k):
        window_sum = sum(nums[:k])
        max_sum = window_sum

        for i in range(k, len(nums)):
            window_sum += nums[i]        # add right element
            window_sum -= nums[i - k]    # remove left element
            max_sum = max(max_sum, window_sum)

        return max_sum

expmale 2: Count subarrays of size k with sum ≥ target

count = 0
window_sum = sum(nums[:k])

if window_sum >= target:
    count += 1

for i in range(k, len(nums)):
    window_sum += nums[i]
    window_sum -= nums[i - k]
    if window_sum >= target:
        count += 1


------------------------------------------------------------------------

two ways to convert list into string:
1. "".join(list1)
This line converts list1 into string

2. str1 = str1[:i] + list[j] + str1[i + 1:]
At ith place we can replace list[j] character. run this mechanism in loop to change entire string.

--------------------------------------------------------------------------------------

list((Counter(nums1) & Counter(nums2)).elements())

What does "&" do for Counters?
It keeps only common keys and takes the minimum count.

.elements() converts the Counter back into a sequence:
example: Counter({2: 2, 1: 3}).elements()
-> 2, 2, 1, 1, 1


---------------------------------------------------------------------------

